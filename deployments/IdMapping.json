{
    "address": "0x194CDd095358eBAA5FD02913e5220E2cd7600713",
    "abi": [
      {
        "inputs": [],
        "stateMutability": "nonpayable",
        "type": "constructor"
      },
      {
        "inputs": [],
        "name": "IdAlreadyGenerated",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "IdOverflow",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "InvalidAddress",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "InvalidId",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "NoAddressFound",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "NoIdGenerated",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "owner",
            "type": "address"
          }
        ],
        "name": "OwnableInvalidOwner",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "account",
            "type": "address"
          }
        ],
        "name": "OwnableUnauthorizedAccount",
        "type": "error"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "user",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "uint256",
            "name": "id",
            "type": "uint256"
          }
        ],
        "name": "IdGenerated",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "previousOwner",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "newOwner",
            "type": "address"
          }
        ],
        "name": "OwnershipTransferStarted",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "previousOwner",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "newOwner",
            "type": "address"
          }
        ],
        "name": "OwnershipTransferred",
        "type": "event"
      },
      {
        "inputs": [],
        "name": "acceptOwnership",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "name": "addressToId",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "generateId",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "_id",
            "type": "uint256"
          }
        ],
        "name": "getAddr",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "_addr",
            "type": "address"
          }
        ],
        "name": "getId",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "owner",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "pendingOwner",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "renounceOwnership",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "_addr",
            "type": "address"
          }
        ],
        "name": "resetIdForAddress",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "newOwner",
            "type": "address"
          }
        ],
        "name": "transferOwnership",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      }
    ],
    "transactionHash": "0x71809251b8de0dd854007f37b7eb79e150cd4a1ca487a665c3e7c880e917182a",
    "receipt": {
      "to": null,
      "from": "0x4F815E2b9619970909A071f65cb32b128aE5fc86",
      "contractAddress": "0x194CDd095358eBAA5FD02913e5220E2cd7600713",
      "transactionIndex": 57,
      "gasUsed": "501607",
      "logsBloom": "0x00000000000000008000000000000000000000000000000000800000000000000000000000020000000000000000000000000000000000000000000000000000000000000008000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000008000000000000000000000000000100000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
      "blockHash": "0x70075353259a7e525f15abe1d0d62f81e2b8f633cd9728958b63cee175aeb4fc",
      "transactionHash": "0x71809251b8de0dd854007f37b7eb79e150cd4a1ca487a665c3e7c880e917182a",
      "logs": [
        {
          "transactionIndex": 57,
          "blockNumber": 7647635,
          "transactionHash": "0x71809251b8de0dd854007f37b7eb79e150cd4a1ca487a665c3e7c880e917182a",
          "address": "0x194CDd095358eBAA5FD02913e5220E2cd7600713",
          "topics": [
            "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
            "0x0000000000000000000000000000000000000000000000000000000000000000",
            "0x0000000000000000000000004f815e2b9619970909a071f65cb32b128ae5fc86"
          ],
          "data": "0x",
          "logIndex": 268,
          "blockHash": "0x70075353259a7e525f15abe1d0d62f81e2b8f633cd9728958b63cee175aeb4fc"
        }
      ],
      "blockNumber": 7647635,
      "cumulativeGasUsed": "13847126",
      "status": 1,
      "byzantium": true
    },
    "args": [],
    "numDeployments": 1,
    "solcInputHash": "e7620ba6b2405fbbc9f9ba0f0597ee57",
    "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IdAlreadyGenerated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IdOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoAddressFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoIdGenerated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"IdGenerated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generateId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"resetIdForAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Inherits from Ownable2Step for secure ownership transfer\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"acceptOwnership()\":{\"details\":\"The new owner accepts the ownership transfer.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"pendingOwner()\":{\"details\":\"Returns the address of the pending owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner. Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\"}},\"stateVariables\":{\"idToAddress\":{\"details\":\"Maps unique IDs back to user addresses\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addressToId(address)\":{\"notice\":\"Maps user addresses to their unique IDs\"}},\"notice\":\"Manages unique ID mappings between addresses and sequential IDs\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/IdMapping.sol\":\"IdMapping\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\\n * old one. This can help prevent common mistakes, such as transfers of ownership to\\n * incorrect accounts, or to contracts that are unable to interact with the\\n * permission system.\\n *\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     *\\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        if (pendingOwner() != sender) {\\n            revert OwnableUnauthorizedAccount(sender);\\n        }\\n        _transferOwnership(sender);\\n    }\\n}\\n\",\"keccak256\":\"0xdcad8898fda432696597752e8ec361b87d85c82cb258115427af006dacf7128c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"contracts/IdMapping.sol\":{\"content\":\"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\n// For Ethereum Sepolia\\nimport { SepoliaZamaFHEVMConfig } from \\\"fhevm/config/ZamaFHEVMConfig.sol\\\";\\n/**\\n * @notice Manages unique ID mappings between addresses and sequential IDs\\n * @dev Inherits from Ownable2Step for secure ownership transfer\\n */\\ncontract IdMapping is Ownable2Step , SepoliaZamaFHEVMConfig {\\n    error IdAlreadyGenerated();\\n    error InvalidAddress();\\n    error IdOverflow();\\n    error NoIdGenerated();\\n    error InvalidId();\\n    error NoAddressFound();\\n\\n    /// @notice Maps user addresses to their unique IDs\\n    mapping(address => uint256) public addressToId;\\n    /// @dev Maps unique IDs back to user addresses\\n    mapping(uint256 => address) private idToAddress;\\n\\n    uint256 private nextId = 1;\\n\\n    event IdGenerated(address indexed user, uint256 indexed id);\\n\\n    constructor() Ownable(msg.sender) {\\n        nextId = 1;\\n    }\\n\\n    function generateId() public returns (uint256) {\\n        if (addressToId[msg.sender] != 0) revert IdAlreadyGenerated();\\n        if (msg.sender == address(0)) revert InvalidAddress();\\n\\n        uint256 newId = nextId;\\n\\n        addressToId[msg.sender] = newId;\\n        idToAddress[newId] = msg.sender;\\n        nextId++;\\n\\n        emit IdGenerated(msg.sender, newId);\\n        return newId;\\n    }\\n\\n    function getId(address _addr) public view returns (uint256) {\\n        if (_addr == address(0)) revert InvalidAddress();\\n        if (addressToId[_addr] == 0) revert NoIdGenerated();\\n        return addressToId[_addr];\\n    }\\n\\n    function getAddr(uint256 _id) public view returns (address) {\\n        if (_id <= 0 || _id >= nextId) revert InvalidId();\\n        address addr = idToAddress[_id];\\n        if (addr == address(0)) revert NoAddressFound();\\n        return addr;\\n    }\\n\\n    function resetIdForAddress(address _addr) external onlyOwner {\\n        uint256 id = addressToId[_addr];\\n        if (id == 0) revert NoIdGenerated();\\n\\n        delete addressToId[_addr];\\n        delete idToAddress[id];\\n    }\\n}\\n\",\"keccak256\":\"0xeb72ca4a70cb458234194b422744dacc7883426bcb81e9bb15d93447d1b43a44\",\"license\":\"MIT\"},\"fhevm/config/ZamaFHEVMConfig.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {TFHE} from \\\"../lib/TFHE.sol\\\";\\nimport {FHEVMConfigStruct} from \\\"../lib/Impl.sol\\\";\\n\\n/**\\n * @title   ZamaFHEVMConfig.\\n * @notice  This library returns the TFHE config for different networks\\n *          with the contract addresses for\\n *          (1) ACL, (2) TFHEExecutor, (3) FHEPayment, (4) KMSVerifier,\\n *          which are deployed & maintained by Zama.\\n */\\nlibrary ZamaFHEVMConfig {\\n    function getSepoliaConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        return\\n            FHEVMConfigStruct({\\n                ACLAddress: 0xFee8407e2f5e3Ee68ad77cAE98c434e637f516e5,\\n                TFHEExecutorAddress: 0x687408aB54661ba0b4aeF3a44156c616c6955E07,\\n                FHEPaymentAddress: 0xFb03BE574d14C256D56F09a198B586bdfc0A9de2,\\n                KMSVerifierAddress: 0x9D6891A6240D6130c54ae243d8005063D05fE14b\\n            });\\n    }\\n\\n    function getEthereumConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        /// TODO\\n    }\\n}\\n\\n/**\\n * @title   SepoliaZamaFHEVMConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Sepolia network (chainId = 11155111).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract SepoliaZamaFHEVMConfig {\\n    constructor() {\\n        TFHE.setFHEVM(ZamaFHEVMConfig.getSepoliaConfig());\\n    }\\n}\\n\\n/**\\n * @title   EthereumZamaFHEVMConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Ethereum (mainnet) network (chainId = 1).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract EthereumZamaFHEVMConfig {\\n    constructor() {\\n        TFHE.setFHEVM(ZamaFHEVMConfig.getEthereumConfig());\\n    }\\n}\\n\",\"keccak256\":\"0x41782f4c707b81399916544fa2e7be94a695fa4ba468542732d29d3e383c0315\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/lib/Impl.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./TFHE.sol\\\";\\n\\n/**\\n * @title   FHEVMConfigStruct\\n * @notice  This struct contains all addresses of core contrats which are needed in a typical dApp.\\n */\\nstruct FHEVMConfigStruct {\\n    address ACLAddress;\\n    address TFHEExecutorAddress;\\n    address FHEPaymentAddress;\\n    address KMSVerifierAddress;\\n}\\n\\n/**\\n * @title   ITFHEExecutor\\n * @notice  This interface contains all functions to conduct FHE operations.\\n */\\ninterface ITFHEExecutor {\\n    function fheAdd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheSub(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMul(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheDiv(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRem(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitAnd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitOr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheBitXor(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheShl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheShr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRotl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheRotr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheEq(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheGe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheGt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheLe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheLt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMin(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheMax(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNeg(uint256 ct) external returns (uint256 result);\\n    function fheNot(uint256 ct) external returns (uint256 result);\\n    function verifyCiphertext(\\n        bytes32 inputHandle,\\n        address callerAddress,\\n        bytes memory inputProof,\\n        bytes1 inputType\\n    ) external returns (uint256 result);\\n    function cast(uint256 ct, bytes1 toType) external returns (uint256 result);\\n    function trivialEncrypt(uint256 ct, bytes1 toType) external returns (uint256 result);\\n    function trivialEncrypt(bytes memory ct, bytes1 toType) external returns (uint256 result);\\n    function fheEq(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheNe(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\\n    function fheIfThenElse(uint256 control, uint256 ifTrue, uint256 ifFalse) external returns (uint256 result);\\n    function fheRand(bytes1 randType) external returns (uint256 result);\\n    function fheRandBounded(uint256 upperBound, bytes1 randType) external returns (uint256 result);\\n}\\n\\n/**\\n * @title   IACL\\n * @notice  This interface contains all functions that are used to conduct operations\\n *          with the ACL contract.\\n */\\ninterface IACL {\\n    function allowTransient(uint256 ciphertext, address account) external;\\n    function allow(uint256 handle, address account) external;\\n    function cleanTransientStorage() external;\\n    function isAllowed(uint256 handle, address account) external view returns (bool);\\n    function allowForDecryption(uint256[] memory handlesList) external;\\n}\\n\\n/**\\n * @title   Impl\\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\\n */\\nlibrary Impl {\\n    /// @dev keccak256(abi.encode(uint256(keccak256(\\\"fhevm.storage.FHEVMConfig\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant FHEVMConfigLocation = 0xed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600;\\n\\n    function getFHEVMConfig() internal pure returns (FHEVMConfigStruct storage $) {\\n        assembly {\\n            $.slot := FHEVMConfigLocation\\n        }\\n    }\\n\\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        $.ACLAddress = fhevmConfig.ACLAddress;\\n        $.TFHEExecutorAddress = fhevmConfig.TFHEExecutorAddress;\\n        $.FHEPaymentAddress = fhevmConfig.FHEPaymentAddress;\\n        $.KMSVerifierAddress = fhevmConfig.KMSVerifierAddress;\\n    }\\n\\n    function add(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheAdd(lhs, rhs, scalarByte);\\n    }\\n\\n    function sub(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheSub(lhs, rhs, scalarByte);\\n    }\\n\\n    function mul(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMul(lhs, rhs, scalarByte);\\n    }\\n\\n    function div(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheDiv(lhs, rhs, scalarByte);\\n    }\\n\\n    function rem(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRem(lhs, rhs, scalarByte);\\n    }\\n\\n    function and(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitAnd(lhs, rhs, scalarByte);\\n    }\\n\\n    function or(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitOr(lhs, rhs, scalarByte);\\n    }\\n\\n    function xor(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitXor(lhs, rhs, scalarByte);\\n    }\\n\\n    function shl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShl(lhs, rhs, scalarByte);\\n    }\\n\\n    function shr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShr(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotl(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotr(lhs, rhs, scalarByte);\\n    }\\n\\n    function eq(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function ge(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGe(lhs, rhs, scalarByte);\\n    }\\n\\n    function gt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGt(lhs, rhs, scalarByte);\\n    }\\n\\n    function le(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLe(lhs, rhs, scalarByte);\\n    }\\n\\n    function lt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLt(lhs, rhs, scalarByte);\\n    }\\n\\n    function min(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMin(lhs, rhs, scalarByte);\\n    }\\n\\n    function max(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMax(lhs, rhs, scalarByte);\\n    }\\n\\n    function neg(uint256 ct) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNeg(ct);\\n    }\\n\\n    function not(uint256 ct) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNot(ct);\\n    }\\n\\n    // If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n    // If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n    function select(uint256 control, uint256 ifTrue, uint256 ifFalse) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheIfThenElse(control, ifTrue, ifFalse);\\n    }\\n\\n    function verify(bytes32 inputHandle, bytes memory inputProof, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).verifyCiphertext(\\n            inputHandle,\\n            msg.sender,\\n            inputProof,\\n            bytes1(toType)\\n        );\\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\\n    }\\n\\n    function cast(uint256 ciphertext, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).cast(ciphertext, bytes1(toType));\\n    }\\n\\n    function trivialEncrypt(uint256 value, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\\n    }\\n\\n    function trivialEncrypt(bytes memory value, uint8 toType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\\n    }\\n\\n    function eq(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function rand(uint8 randType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRand(bytes1(randType));\\n    }\\n\\n    function randBounded(uint256 upperBound, uint8 randType) internal returns (uint256 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRandBounded(upperBound, bytes1(randType));\\n    }\\n\\n    function allowTransient(uint256 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allowTransient(handle, account);\\n    }\\n\\n    function allow(uint256 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allow(handle, account);\\n    }\\n\\n    function cleanTransientStorage() internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).cleanTransientStorage();\\n    }\\n\\n    function isAllowed(uint256 handle, address account) internal view returns (bool) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        return IACL($.ACLAddress).isAllowed(handle, account);\\n    }\\n}\\n\",\"keccak256\":\"0x89d4968cd956a8931f1a8a177b3bef1c6cf88a03665083db74430add50b88f21\",\"license\":\"BSD-3-Clause-Clear\"},\"fhevm/lib/TFHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./Impl.sol\\\";\\n\\ntype ebool is uint256;\\ntype euint4 is uint256;\\ntype euint8 is uint256;\\ntype euint16 is uint256;\\ntype euint32 is uint256;\\ntype euint64 is uint256;\\ntype euint128 is uint256;\\ntype euint256 is uint256;\\ntype eaddress is uint256;\\ntype ebytes64 is uint256;\\ntype ebytes128 is uint256;\\ntype ebytes256 is uint256;\\ntype einput is bytes32;\\n\\n/**\\n * @title   Common\\n * @notice  This library contains all the values used to communicate types to the run time.\\n */\\nlibrary Common {\\n    uint8 internal constant ebool_t = 0;\\n    uint8 internal constant euint4_t = 1;\\n    uint8 internal constant euint8_t = 2;\\n    uint8 internal constant euint16_t = 3;\\n    uint8 internal constant euint32_t = 4;\\n    uint8 internal constant euint64_t = 5;\\n    uint8 internal constant euint128_t = 6;\\n    uint8 internal constant euint160_t = 7;\\n    uint8 internal constant euint256_t = 8;\\n    uint8 internal constant ebytes64_t = 9;\\n    uint8 internal constant ebytes128_t = 10;\\n    uint8 internal constant ebytes256_t = 11;\\n}\\n\\n/**\\n * @title   TFHE\\n * @notice  This library is the interaction point for all smart contract developers\\n *          that interact with TFHE.\\n */\\nlibrary TFHE {\\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\\n        Impl.setFHEVM(fhevmConfig);\\n    }\\n\\n    // Return true if the enrypted bool is initialized and false otherwise.\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint4 v) internal pure returns (bool) {\\n        return euint4.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint64 v) internal pure returns (bool) {\\n        return euint64.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint128 v) internal pure returns (bool) {\\n        return euint128.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted integer is initialized and false otherwise.\\n    function isInitialized(euint256 v) internal pure returns (bool) {\\n        return euint256.unwrap(v) != 0;\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(a), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.add(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint8 a, euint4 b) internal returns (euint4) {\\n        euint4 aEnc = asEuint4(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.sub(euint4.unwrap(aEnc), euint4.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.mul(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.div(euint4.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rem(euint4.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.and(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.or(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.xor(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint4 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.min(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint8 a, euint4 b) internal returns (euint4) {\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.max(euint4.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint4 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\\n        euint8 aEnc = asEuint8(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.div(euint8.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint4 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\\n        euint16 aEnc = asEuint16(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.div(euint16.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint4 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\\n        euint32 aEnc = asEuint32(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.div(euint32.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint4 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\\n        euint64 aEnc = asEuint64(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.div(euint64.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint4 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\\n        euint128 aEnc = asEuint128(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.div(euint128.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint4 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint4 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint4(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate add(a, b) and return the result.\\n    function add(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.add(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate sub(a, b) and return the result.\\n    function sub(uint256 a, euint256 b) internal returns (euint256) {\\n        euint256 aEnc = asEuint256(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.sub(euint256.unwrap(aEnc), euint256.unwrap(b), false));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate mul(a, b) and return the result.\\n    function mul(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.mul(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate div(a, b) and return the result.\\n    function div(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.div(euint256.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate rem(a, b) and return the result.\\n    function rem(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rem(euint256.unwrap(a), uint256(b)));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate ge(a, b) and return the result.\\n    function ge(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate gt(a, b) and return the result.\\n    function gt(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.le(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate le(a, b) and return the result.\\n    function le(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate lt(a, b) and return the result.\\n    function lt(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate min(a, b) and return the result.\\n    function min(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.min(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate max(a, b) and return the result.\\n    function max(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.max(euint256.unwrap(b), uint256(a), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.shl(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.shr(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rotl(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint4 a, uint8 b) internal returns (euint4) {\\n        if (!isInitialized(a)) {\\n            a = asEuint4(0);\\n        }\\n        return euint4.wrap(Impl.rotr(euint4.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate shl(a, b) and return the result.\\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate shr(a, b) and return the result.\\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate rotl(a, b) and return the result.\\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    // Evaluate rotr(a, b) and return the result.\\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), uint256(b), true));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint4 a, euint4 b) internal returns (euint4) {\\n        return euint4.wrap(Impl.select(ebool.unwrap(control), euint4.unwrap(a), euint4.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\\n    }\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\\n    }\\n    // Cast an encrypted integer from euint8 to euint4.\\n    function asEuint4(euint8 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint8.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint4.\\n    function asEuint4(euint16 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint16.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint4.\\n    function asEuint4(euint32 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint32.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint4.\\n    function asEuint4(euint64 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint64.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint4.\\n    function asEuint4(euint128 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint128.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint4.\\n    function asEuint4(euint256 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(euint256.unwrap(value), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to ebool.\\n    function asEbool(euint4 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint4'.\\n    function asEuint4(ebool b) internal returns (euint4) {\\n        return euint4.wrap(Impl.cast(ebool.unwrap(b), Common.euint4_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint8.\\n    function asEuint8(euint4 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint4.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint8.\\n    function asEuint8(euint16 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint8.\\n    function asEuint8(euint32 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint8.\\n    function asEuint8(euint64 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint8.\\n    function asEuint8(euint128 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint8.\\n    function asEuint8(euint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to ebool.\\n    function asEbool(euint8 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted boolean.\\n    function asEbool(einput inputHandle, bytes memory inputProof) internal returns (ebool) {\\n        return ebool.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebool_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted boolean.\\n    function asEbool(uint256 value) internal returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.ebool_t));\\n    }\\n\\n    // Convert a plaintext boolean to an encrypted boolean.\\n    function asEbool(bool value) internal returns (ebool) {\\n        if (value) {\\n            return asEbool(1);\\n        } else {\\n            return asEbool(0);\\n        }\\n    }\\n\\n    // Converts an 'ebool' to an 'euint8'.\\n    function asEuint8(ebool value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(ebool.unwrap(value), Common.euint8_t));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate and(a, b) and return the result.\\n    function and(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.and(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate or(a, b) and return the result.\\n    function or(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.or(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(ebool a, bool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), b ? 1 : 0, true));\\n    }\\n\\n    // Evaluate xor(a, b) and return the result.\\n    function xor(bool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), a ? 1 : 0, true));\\n    }\\n\\n    function not(ebool a) internal returns (ebool) {\\n        return ebool.wrap(Impl.not(ebool.unwrap(a)));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint16.\\n    function asEuint16(euint4 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint4.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint16.\\n    function asEuint16(euint8 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint16.\\n    function asEuint16(euint32 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint16.\\n    function asEuint16(euint64 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint16.\\n    function asEuint16(euint128 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint16.\\n    function asEuint16(euint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to ebool.\\n    function asEbool(euint16 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint16'.\\n    function asEuint16(ebool b) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), Common.euint16_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint32.\\n    function asEuint32(euint4 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint4.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint32.\\n    function asEuint32(euint8 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint32.\\n    function asEuint32(euint16 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint32.\\n    function asEuint32(euint64 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint32.\\n    function asEuint32(euint128 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint32.\\n    function asEuint32(euint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to ebool.\\n    function asEbool(euint32 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint32'.\\n    function asEuint32(ebool b) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), Common.euint32_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint64.\\n    function asEuint64(euint4 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint4.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint64.\\n    function asEuint64(euint8 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint64.\\n    function asEuint64(euint16 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint64.\\n    function asEuint64(euint32 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint64.\\n    function asEuint64(euint128 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint64.\\n    function asEuint64(euint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to ebool.\\n    function asEbool(euint64 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint64'.\\n    function asEuint64(ebool b) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), Common.euint64_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint128.\\n    function asEuint128(euint4 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint4.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint128.\\n    function asEuint128(euint8 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint128.\\n    function asEuint128(euint16 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint128.\\n    function asEuint128(euint32 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint128.\\n    function asEuint128(euint64 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to euint128.\\n    function asEuint128(euint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to ebool.\\n    function asEbool(euint128 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint128'.\\n    function asEuint128(ebool b) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), Common.euint128_t));\\n    }\\n\\n    // Cast an encrypted integer from euint4 to euint256.\\n    function asEuint256(euint4 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint4.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint8 to euint256.\\n    function asEuint256(euint8 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint16 to euint256.\\n    function asEuint256(euint16 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint32 to euint256.\\n    function asEuint256(euint32 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint64 to euint256.\\n    function asEuint256(euint64 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint128 to euint256.\\n    function asEuint256(euint128 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), Common.euint256_t));\\n    }\\n\\n    // Cast an encrypted integer from euint256 to ebool.\\n    function asEbool(euint256 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    // Converts an 'ebool' to an 'euint256'.\\n    function asEuint256(ebool b) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), Common.euint256_t));\\n    }\\n\\n    function neg(euint4 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.neg(euint4.unwrap(value)));\\n    }\\n\\n    function not(euint4 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.not(euint4.unwrap(value)));\\n    }\\n\\n    function neg(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\\n    }\\n\\n    function not(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\\n    }\\n\\n    function neg(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\\n    }\\n\\n    function not(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\\n    }\\n\\n    function neg(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\\n    }\\n\\n    function not(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\\n    }\\n\\n    function neg(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\\n    }\\n\\n    function not(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\\n    }\\n\\n    function neg(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\\n    }\\n\\n    function not(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\\n    }\\n\\n    function neg(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\\n    }\\n\\n    function not(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint4 integer.\\n    function asEuint4(einput inputHandle, bytes memory inputProof) internal returns (euint4) {\\n        return euint4.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint4_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint4 integer.\\n    function asEuint4(uint256 value) internal returns (euint4) {\\n        return euint4.wrap(Impl.trivialEncrypt(value, Common.euint4_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\\n    function asEuint8(einput inputHandle, bytes memory inputProof) internal returns (euint8) {\\n        return euint8.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint8_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint8 integer.\\n    function asEuint8(uint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.euint8_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\\n    function asEuint16(einput inputHandle, bytes memory inputProof) internal returns (euint16) {\\n        return euint16.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint16_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint16 integer.\\n    function asEuint16(uint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.euint16_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\\n    function asEuint32(einput inputHandle, bytes memory inputProof) internal returns (euint32) {\\n        return euint32.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint32_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint32 integer.\\n    function asEuint32(uint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.euint32_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\\n    function asEuint64(einput inputHandle, bytes memory inputProof) internal returns (euint64) {\\n        return euint64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint64_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint64 integer.\\n    function asEuint64(uint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.trivialEncrypt(value, Common.euint64_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\\n    function asEuint128(einput inputHandle, bytes memory inputProof) internal returns (euint128) {\\n        return euint128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint128_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint128 integer.\\n    function asEuint128(uint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.trivialEncrypt(value, Common.euint128_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\\n    function asEuint256(einput inputHandle, bytes memory inputProof) internal returns (euint256) {\\n        return euint256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint256_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted euint256 integer.\\n    function asEuint256(uint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.trivialEncrypt(value, Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted boolean.\\n    function randEbool() internal returns (ebool) {\\n        return ebool.wrap(Impl.rand(Common.ebool_t));\\n    }\\n\\n    // Generates a random encrypted 4-bit unsigned integer.\\n    function randEuint4() internal returns (euint4) {\\n        return euint4.wrap(Impl.rand(Common.euint4_t));\\n    }\\n\\n    // Generates a random encrypted 4-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint4(uint8 upperBound) internal returns (euint4) {\\n        return euint4.wrap(Impl.randBounded(upperBound, Common.euint4_t));\\n    }\\n\\n    // Generates a random encrypted 8-bit unsigned integer.\\n    function randEuint8() internal returns (euint8) {\\n        return euint8.wrap(Impl.rand(Common.euint8_t));\\n    }\\n\\n    // Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\\n        return euint8.wrap(Impl.randBounded(upperBound, Common.euint8_t));\\n    }\\n\\n    // Generates a random encrypted 16-bit unsigned integer.\\n    function randEuint16() internal returns (euint16) {\\n        return euint16.wrap(Impl.rand(Common.euint16_t));\\n    }\\n\\n    // Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\\n        return euint16.wrap(Impl.randBounded(upperBound, Common.euint16_t));\\n    }\\n\\n    // Generates a random encrypted 32-bit unsigned integer.\\n    function randEuint32() internal returns (euint32) {\\n        return euint32.wrap(Impl.rand(Common.euint32_t));\\n    }\\n\\n    // Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\\n        return euint32.wrap(Impl.randBounded(upperBound, Common.euint32_t));\\n    }\\n\\n    // Generates a random encrypted 64-bit unsigned integer.\\n    function randEuint64() internal returns (euint64) {\\n        return euint64.wrap(Impl.rand(Common.euint64_t));\\n    }\\n\\n    // Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\\n        return euint64.wrap(Impl.randBounded(upperBound, Common.euint64_t));\\n    }\\n\\n    // Generates a random encrypted 128-bit unsigned integer.\\n    function randEuint128() internal returns (euint128) {\\n        return euint128.wrap(Impl.rand(Common.euint128_t));\\n    }\\n\\n    // Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\\n        return euint128.wrap(Impl.randBounded(upperBound, Common.euint128_t));\\n    }\\n\\n    // Generates a random encrypted 256-bit unsigned integer.\\n    function randEuint256() internal returns (euint256) {\\n        return euint256.wrap(Impl.rand(Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\\n    // The upperBound must be a power of 2.\\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\\n        return euint256.wrap(Impl.randBounded(upperBound, Common.euint256_t));\\n    }\\n\\n    // Generates a random encrypted 512-bit unsigned integer.\\n    function randEbytes64() internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.rand(Common.ebytes64_t));\\n    }\\n\\n    // Generates a random encrypted 1024-bit unsigned integer.\\n    function randEbytes128() internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.rand(Common.ebytes128_t));\\n    }\\n\\n    // Generates a random encrypted 2048-bit unsigned integer.\\n    function randEbytes256() internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.rand(Common.ebytes256_t));\\n    }\\n\\n    // Convert an inputHandle with corresponding inputProof to an encrypted eaddress.\\n    function asEaddress(einput inputHandle, bytes memory inputProof) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint160_t));\\n    }\\n\\n    // Convert a plaintext value to an encrypted address.\\n    function asEaddress(address value) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(uint160(value), Common.euint160_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes64 value.\\n    function asEbytes64(einput inputHandle, bytes memory inputProof) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes64_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 64.\\n    function padToBytes64(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 64, \\\"Input exceeds 64 bytes\\\");\\n        bytes memory result = new bytes(64);\\n        uint256 paddingLength = 64 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 64 - to an encrypted Bytes64.\\n    function asEbytes64(bytes memory value) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.trivialEncrypt(value, Common.ebytes64_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes128 value.\\n    function asEbytes128(einput inputHandle, bytes memory inputProof) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes128_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 128.\\n    function padToBytes128(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 128, \\\"Input exceeds 128 bytes\\\");\\n        bytes memory result = new bytes(128);\\n        uint256 paddingLength = 128 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 128 - to an encrypted Bytes128.\\n    function asEbytes128(bytes memory value) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.trivialEncrypt(value, Common.ebytes128_t));\\n    }\\n\\n    // Convert the given inputHandle and inputProof to an encrypted ebytes256 value.\\n    function asEbytes256(einput inputHandle, bytes memory inputProof) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes256_t));\\n    }\\n\\n    // Left-pad a bytes array with zeros such that it becomes of length 256.\\n    function padToBytes256(bytes memory input) internal pure returns (bytes memory) {\\n        require(input.length <= 256, \\\"Input exceeds 256 bytes\\\");\\n        bytes memory result = new bytes(256);\\n        uint256 paddingLength = 256 - input.length;\\n        for (uint256 i = 0; i < paddingLength; i++) {\\n            result[i] = 0;\\n        }\\n        for (uint256 i = 0; i < input.length; i++) {\\n            result[paddingLength + i] = input[i];\\n        }\\n        return result;\\n    }\\n\\n    // Convert a plaintext value - must be a bytes array of size 256 - to an encrypted Bytes256.\\n    function asEbytes256(bytes memory value) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.trivialEncrypt(value, Common.ebytes256_t));\\n    }\\n\\n    // Return true if the enrypted address is initialized and false otherwise.\\n    function isInitialized(eaddress v) internal pure returns (bool) {\\n        return eaddress.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes64 v) internal pure returns (bool) {\\n        return ebytes64.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes128 v) internal pure returns (bool) {\\n        return ebytes128.unwrap(v) != 0;\\n    }\\n\\n    // Return true if the enrypted value is initialized and false otherwise.\\n    function isInitialized(ebytes256 v) internal pure returns (bool) {\\n        return ebytes256.unwrap(v) != 0;\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bool b, ebool a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bool b, ebool a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        uint256 bProc = b ? 1 : 0;\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(address b, eaddress a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(address b, eaddress a) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        uint256 bProc = uint256(uint160(b));\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes64 a, ebytes64 b) internal returns (ebytes64) {\\n        return ebytes64.wrap(Impl.select(ebool.unwrap(control), ebytes64.unwrap(a), ebytes64.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes128 a, ebytes128 b) internal returns (ebytes128) {\\n        return ebytes128.wrap(Impl.select(ebool.unwrap(control), ebytes128.unwrap(a), ebytes128.unwrap(b)));\\n    }\\n\\n    // If 'control''s value is 'true', the result has the same value as 'a'.\\n    // If 'control''s value is 'false', the result has the same value as 'b'.\\n    function select(ebool control, ebytes256 a, ebytes256 b) internal returns (ebytes256) {\\n        return ebytes256.wrap(Impl.select(ebool.unwrap(control), ebytes256.unwrap(a), ebytes256.unwrap(b)));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes64 a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes64 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes64 a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes64 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes64(padToBytes64(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes128 a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes128 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes128 a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes128 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes128(padToBytes128(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes256 a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(ebytes256 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate eq(a, b) and return the result.\\n    function eq(bytes memory a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(b), a, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes256 a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(ebytes256 a, bytes memory b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), b, true));\\n    }\\n\\n    // Evaluate ne(a, b) and return the result.\\n    function ne(bytes memory a, ebytes256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbytes256(padToBytes256(hex\\\"\\\"));\\n        }\\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(b), a, true));\\n    }\\n\\n    // cleans the transient storage of ACL containing all the allowedTransient accounts\\n    // to be used for integration with Account Abstraction or when bundling UserOps calling the FHEVMCoprocessor\\n    function cleanTransientStorage() internal {\\n        return Impl.cleanTransientStorage();\\n    }\\n\\n    function isAllowed(ebool value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), account);\\n    }\\n    function isAllowed(euint4 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint4.unwrap(value), account);\\n    }\\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), account);\\n    }\\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), account);\\n    }\\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), account);\\n    }\\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), account);\\n    }\\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), account);\\n    }\\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), account);\\n    }\\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), account);\\n    }\\n\\n    function isAllowed(ebytes256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebytes256.unwrap(value), account);\\n    }\\n\\n    function isSenderAllowed(ebool value) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint4 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint4.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\\n    }\\n\\n    function isSenderAllowed(ebytes256 value) internal view returns (bool) {\\n        return Impl.isAllowed(ebytes256.unwrap(value), msg.sender);\\n    }\\n\\n    function allow(ebool value, address account) internal {\\n        Impl.allow(ebool.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebool value) internal {\\n        Impl.allow(ebool.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint4 value, address account) internal {\\n        Impl.allow(euint4.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint4 value) internal {\\n        Impl.allow(euint4.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint8 value, address account) internal {\\n        Impl.allow(euint8.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint8 value) internal {\\n        Impl.allow(euint8.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint16 value, address account) internal {\\n        Impl.allow(euint16.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint16 value) internal {\\n        Impl.allow(euint16.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint32 value, address account) internal {\\n        Impl.allow(euint32.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint32 value) internal {\\n        Impl.allow(euint32.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint64 value, address account) internal {\\n        Impl.allow(euint64.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint64 value) internal {\\n        Impl.allow(euint64.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint128 value, address account) internal {\\n        Impl.allow(euint128.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint128 value) internal {\\n        Impl.allow(euint128.unwrap(value), address(this));\\n    }\\n\\n    function allow(euint256 value, address account) internal {\\n        Impl.allow(euint256.unwrap(value), account);\\n    }\\n\\n    function allowThis(euint256 value) internal {\\n        Impl.allow(euint256.unwrap(value), address(this));\\n    }\\n\\n    function allow(eaddress value, address account) internal {\\n        Impl.allow(eaddress.unwrap(value), account);\\n    }\\n\\n    function allowThis(eaddress value) internal {\\n        Impl.allow(eaddress.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes64 value, address account) internal {\\n        Impl.allow(ebytes64.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes64 value) internal {\\n        Impl.allow(ebytes64.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes128 value, address account) internal {\\n        Impl.allow(ebytes128.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes128 value) internal {\\n        Impl.allow(ebytes128.unwrap(value), address(this));\\n    }\\n\\n    function allow(ebytes256 value, address account) internal {\\n        Impl.allow(ebytes256.unwrap(value), account);\\n    }\\n\\n    function allowThis(ebytes256 value) internal {\\n        Impl.allow(ebytes256.unwrap(value), address(this));\\n    }\\n\\n    function allowTransient(ebool value, address account) internal {\\n        Impl.allowTransient(ebool.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint4 value, address account) internal {\\n        Impl.allowTransient(euint4.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint8 value, address account) internal {\\n        Impl.allowTransient(euint8.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint16 value, address account) internal {\\n        Impl.allowTransient(euint16.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint32 value, address account) internal {\\n        Impl.allowTransient(euint32.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint64 value, address account) internal {\\n        Impl.allowTransient(euint64.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint128 value, address account) internal {\\n        Impl.allowTransient(euint128.unwrap(value), account);\\n    }\\n\\n    function allowTransient(euint256 value, address account) internal {\\n        Impl.allowTransient(euint256.unwrap(value), account);\\n    }\\n\\n    function allowTransient(eaddress value, address account) internal {\\n        Impl.allowTransient(eaddress.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes64 value, address account) internal {\\n        Impl.allowTransient(ebytes64.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes128 value, address account) internal {\\n        Impl.allowTransient(ebytes128.unwrap(value), account);\\n    }\\n\\n    function allowTransient(ebytes256 value, address account) internal {\\n        Impl.allowTransient(ebytes256.unwrap(value), account);\\n    }\\n}\\n\",\"keccak256\":\"0x221799c8332f83ab65a0b71746409f0c2c89f1cd8d9ba4091d967c667e1df734\",\"license\":\"BSD-3-Clause-Clear\"}},\"version\":1}",
    "bytecode": "0x60806040526001600455348015610014575f80fd5b50338061003a57604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b610043816100f1565b506100e76100e2604080516080810182525f808252602082018190529181018290526060810191909152506040805160808101825273fee8407e2f5e3ee68ad77cae98c434e637f516e5815273687408ab54661ba0b4aef3a44156c616c6955e07602082015273fb03be574d14c256d56f09a198b586bdfc0a9de291810191909152739d6891a6240d6130c54ae243d8005063d05fe14b606082015290565b61010d565b6001600455610238565b600180546001600160a01b031916905561010a816101e9565b50565b80517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60080546001600160a01b03199081166001600160a01b039384161790915560208301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6018054831691841691909117905560408301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6028054831691841691909117905560608301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6038054909216921691909117905550565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b610577806102455f395ff3fe608060405234801561000f575f80fd5b50600436106100b9575f3560e01c80638da5cb5b11610072578063d81f84b711610058578063d81f84b714610153578063e30c397814610166578063f2fde38b14610177575f80fd5b80638da5cb5b14610110578063cb0e0d7d14610134575f80fd5b80636f8dcb3d116100a25780636f8dcb3d146100f8578063715018a61461010057806379ba509714610108575f80fd5b80631998e200146100bd57806365f68c89146100d2575b5f80fd5b6100d06100cb366004610502565b61018a565b005b6100e56100e0366004610502565b610201565b6040519081526020015b60405180910390f35b6100e561027b565b6100d061033e565b6100d0610351565b5f546001600160a01b03165b6040516001600160a01b0390911681526020016100ef565b6100e5610142366004610502565b60026020525f908152604090205481565b61011c61016136600461052f565b61039a565b6001546001600160a01b031661011c565b6100d0610185366004610502565b610403565b610192610473565b6001600160a01b0381165f90815260026020526040812054908190036101cb576040516303aebe7360e01b815260040160405180910390fd5b6001600160a01b039091165f908152600260209081526040808320839055928252600390522080546001600160a01b0319169055565b5f6001600160a01b0382166102295760405163e6c4247b60e01b815260040160405180910390fd5b6001600160a01b0382165f908152600260205260408120549003610260576040516303aebe7360e01b815260040160405180910390fd5b506001600160a01b03165f9081526002602052604090205490565b335f90815260026020526040812054156102a8576040516354c5785d60e11b815260040160405180910390fd5b336102c65760405163e6c4247b60e01b815260040160405180910390fd5b60048054335f8181526002602090815260408083208590558483526003909152812080546001600160a01b031916909217909155825491929061030883610546565b9091555050604051819033907f633a062bfc4338338540167878dec92e855f952c8fb099a9ffc4f0728d721c86905f90a3919050565b610346610473565b61034f5f61049f565b565b60015433906001600160a01b0316811461038e5760405163118cdaa760e01b81526001600160a01b03821660048201526024015b60405180910390fd5b6103978161049f565b50565b5f8115806103aa57506004548210155b156103c857604051631bf4348160e31b815260040160405180910390fd5b5f828152600360205260409020546001600160a01b0316806103fd576040516371678f1560e11b815260040160405180910390fd5b92915050565b61040b610473565b600180546001600160a01b0383166001600160a01b0319909116811790915561043b5f546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b5f546001600160a01b0316331461034f5760405163118cdaa760e01b8152336004820152602401610385565b600180546001600160a01b0319169055610397815f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f60208284031215610512575f80fd5b81356001600160a01b0381168114610528575f80fd5b9392505050565b5f6020828403121561053f575f80fd5b5035919050565b5f6001820161056357634e487b7160e01b5f52601160045260245ffd5b506001019056fea164736f6c6343000818000a",
    "deployedBytecode": "0x608060405234801561000f575f80fd5b50600436106100b9575f3560e01c80638da5cb5b11610072578063d81f84b711610058578063d81f84b714610153578063e30c397814610166578063f2fde38b14610177575f80fd5b80638da5cb5b14610110578063cb0e0d7d14610134575f80fd5b80636f8dcb3d116100a25780636f8dcb3d146100f8578063715018a61461010057806379ba509714610108575f80fd5b80631998e200146100bd57806365f68c89146100d2575b5f80fd5b6100d06100cb366004610502565b61018a565b005b6100e56100e0366004610502565b610201565b6040519081526020015b60405180910390f35b6100e561027b565b6100d061033e565b6100d0610351565b5f546001600160a01b03165b6040516001600160a01b0390911681526020016100ef565b6100e5610142366004610502565b60026020525f908152604090205481565b61011c61016136600461052f565b61039a565b6001546001600160a01b031661011c565b6100d0610185366004610502565b610403565b610192610473565b6001600160a01b0381165f90815260026020526040812054908190036101cb576040516303aebe7360e01b815260040160405180910390fd5b6001600160a01b039091165f908152600260209081526040808320839055928252600390522080546001600160a01b0319169055565b5f6001600160a01b0382166102295760405163e6c4247b60e01b815260040160405180910390fd5b6001600160a01b0382165f908152600260205260408120549003610260576040516303aebe7360e01b815260040160405180910390fd5b506001600160a01b03165f9081526002602052604090205490565b335f90815260026020526040812054156102a8576040516354c5785d60e11b815260040160405180910390fd5b336102c65760405163e6c4247b60e01b815260040160405180910390fd5b60048054335f8181526002602090815260408083208590558483526003909152812080546001600160a01b031916909217909155825491929061030883610546565b9091555050604051819033907f633a062bfc4338338540167878dec92e855f952c8fb099a9ffc4f0728d721c86905f90a3919050565b610346610473565b61034f5f61049f565b565b60015433906001600160a01b0316811461038e5760405163118cdaa760e01b81526001600160a01b03821660048201526024015b60405180910390fd5b6103978161049f565b50565b5f8115806103aa57506004548210155b156103c857604051631bf4348160e31b815260040160405180910390fd5b5f828152600360205260409020546001600160a01b0316806103fd576040516371678f1560e11b815260040160405180910390fd5b92915050565b61040b610473565b600180546001600160a01b0383166001600160a01b0319909116811790915561043b5f546001600160a01b031690565b6001600160a01b03167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b5f546001600160a01b0316331461034f5760405163118cdaa760e01b8152336004820152602401610385565b600180546001600160a01b0319169055610397815f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f60208284031215610512575f80fd5b81356001600160a01b0381168114610528575f80fd5b9392505050565b5f6020828403121561053f575f80fd5b5035919050565b5f6001820161056357634e487b7160e01b5f52601160045260245ffd5b506001019056fea164736f6c6343000818000a",
    "devdoc": {
      "details": "Inherits from Ownable2Step for secure ownership transfer",
      "errors": {
        "OwnableInvalidOwner(address)": [
          {
            "details": "The owner is not a valid owner account. (eg. `address(0)`)"
          }
        ],
        "OwnableUnauthorizedAccount(address)": [
          {
            "details": "The caller account is not authorized to perform an operation."
          }
        ]
      },
      "kind": "dev",
      "methods": {
        "acceptOwnership()": {
          "details": "The new owner accepts the ownership transfer."
        },
        "owner()": {
          "details": "Returns the address of the current owner."
        },
        "pendingOwner()": {
          "details": "Returns the address of the pending owner."
        },
        "renounceOwnership()": {
          "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
        },
        "transferOwnership(address)": {
          "details": "Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner. Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer."
        }
      },
      "stateVariables": {
        "idToAddress": {
          "details": "Maps unique IDs back to user addresses"
        }
      },
      "version": 1
    },
    "userdoc": {
      "kind": "user",
      "methods": {
        "addressToId(address)": {
          "notice": "Maps user addresses to their unique IDs"
        }
      },
      "notice": "Manages unique ID mappings between addresses and sequential IDs",
      "version": 1
    },
    "storageLayout": {
      "storage": [
        {
          "astId": 387,
          "contract": "contracts/IdMapping.sol:IdMapping",
          "label": "_owner",
          "offset": 0,
          "slot": "0",
          "type": "t_address"
        },
        {
          "astId": 535,
          "contract": "contracts/IdMapping.sol:IdMapping",
          "label": "_pendingOwner",
          "offset": 0,
          "slot": "1",
          "type": "t_address"
        },
        {
          "astId": 996,
          "contract": "contracts/IdMapping.sol:IdMapping",
          "label": "addressToId",
          "offset": 0,
          "slot": "2",
          "type": "t_mapping(t_address,t_uint256)"
        },
        {
          "astId": 1001,
          "contract": "contracts/IdMapping.sol:IdMapping",
          "label": "idToAddress",
          "offset": 0,
          "slot": "3",
          "type": "t_mapping(t_uint256,t_address)"
        },
        {
          "astId": 1004,
          "contract": "contracts/IdMapping.sol:IdMapping",
          "label": "nextId",
          "offset": 0,
          "slot": "4",
          "type": "t_uint256"
        }
      ],
      "types": {
        "t_address": {
          "encoding": "inplace",
          "label": "address",
          "numberOfBytes": "20"
        },
        "t_mapping(t_address,t_uint256)": {
          "encoding": "mapping",
          "key": "t_address",
          "label": "mapping(address => uint256)",
          "numberOfBytes": "32",
          "value": "t_uint256"
        },
        "t_mapping(t_uint256,t_address)": {
          "encoding": "mapping",
          "key": "t_uint256",
          "label": "mapping(uint256 => address)",
          "numberOfBytes": "32",
          "value": "t_address"
        },
        "t_uint256": {
          "encoding": "inplace",
          "label": "uint256",
          "numberOfBytes": "32"
        }
      }
    }
  }